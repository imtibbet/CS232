h1. Programmable Lights II

h3. Write Up

h5. Include a description of your top-level design.
The top-level design we implemented for this project was very similar to the first programmable light project with a Moore state machine being implemented in VHDL. This time though we have 3 states, sFetch, sExecute1, and sExecute2. Having two separate execute states allows a value to be loaded into the SRC register first before being operated on and putting the output into a destination register. This project was really about implementing more functions necessary for true computer. Instead of just changing around the bits in the light register, we can now perform binary operations on those bits, move data between registers, and branch to instructions both conditionally and unconditionally. The state machine does function very similarly to before with case statements for each of the different op codes and nested case statements for individual cases.  
h5. Include the two programs you wrote.

h5. Include the picture of your simulation of your favorite program.

h3. Hardware Testing:
After getting our code to compile we attempted to simulate a program, but ran into problems so we went straight to the board. Also running into issues here with our program not functioning as desired, we used the red lights to display the address and the first 5 bits of the ACC just to check what was going wrong. This helped us identify a few minor problems in the code (such as using the wrong bits for the destination) that quickly sorted out our program. From here the majority of Ianâ€™s time was spent implementing the python extension that parses a text input into a set of instructions for our computer. Ryan then helped mesh these slight changes into the programmable lights program and troubleshoot errors in the created instructions. 

h3. Extensions:

h5. Make longer programs (make the ROM bigger).
We accomplished this by utilizing a specific loop register so the conditional branch always checks if the loop register is zero. This allows us to use all 8 bits after the op code for the branching instructions as address bits.

h5. Write more programs.

h5. Write a simple assembler (in python, for example) that converts instructions from a simple, human readable language, into the set of machine instructions for your pldrom.

Maybe not so simple, but our vhdlCompiler.py does allow the user to provide english instructions (from a list of valid keywords we define) for a program in an input file, pass that input file to the python on the command line (and optionally specify an output file on the command line as well), which writes vhdl code to the output file for the program described. Our keywords are:
* Do_# - begin a loop that iterates # times
* Loop - end a loop
* Set_######## - sets each of the 8 lights to their #, either 1 or 0
* On - turn all 8 lights on
* Off - turn all 8 lights off
* Shift_Left - shift 8 lights left by one
* Shift_Right - shift 8 lights right by one
* Rotate_Left - rotate rightmost of 8 lights to the leftmost
* Rotate_Right - rotate leftmost of 8 lights to the rightmost
* Invert - flip all on lights to off and visa versa

All instructions in this code refer to the light register (LR, the 8 green lights on the board), so none of the internal implementation (ACC, 10 bit instructions, etc) are visible to the user. Instead, the python code handles validating that they use only legal keywords, do not have neted loops, provide loop counts, do not exceed to number of available addresses, etc. By modifying fields this compiler is extensible to different length addresses, but ours assumes 8 bit addresses and therefore restricts the user to less than 128 loop counts. Our modified table, describing how we modified our design to implement a LOOP register and have 8 bit addresses can be found [here|^newSpecProj5PythExt.htm].

The method that does most of the vhdl composition work is given in the code snippet below:

{code:title=vhdlCompiler.py|borderStyle=solid}
    def getMachineInstructions(self,word):
        instrList = []
        instructions = "-- " + word + "\n"
        if word.split("_")[0] == "DO":
            loopCountStr = "{0:b}".format(self.loopCount)
            if len(loopCountStr) > self.addrLength:
                self.errorMessage += ("Error: new address exceeds give address length" +
                                      " of {}\n".format(self.addrLength))
            while len(loopCountStr) < self.addrLength:
                loopCountStr = "0" + loopCountStr
            instrList += [["\"001010" + loopCountStr[4:8] + "\"","set low 4 bits of ACC"]]
            instrList += [["\"001110" + loopCountStr[0:4] + "\"","set high 4 bits of ACC"]]
            instrList += [["\"0110000100\"","move ACC into LOOP"]]
        elif word == "LOOP":
            instructions += self.subOneFromLOOP()
            branchZWhenAddr = self.getNewAddress()
            branchUWhenAddr = self.getNewAddress()
            branchZToAddr = self.getNewAddress()
            instructions += ("\"11" + branchZToAddr + "\"" + 
                             " when addr = \"" + 
                             branchZWhenAddr +
                             "\" else -- " +
                             "break when LOOP is zero\n")
            instructions += ("\"10" + self.getStartLoopAddr() + "\""
                             " when addr = \"" + 
                             branchUWhenAddr +
                             "\" else -- " +
                             "branch unconditional to top of loop otherwise\n")
        elif word == "ON":
            instrList += [["\"0001110000\"","move all 1's into LR"]]
        elif word == "OFF":
            instrList += [["\"0000110000\"","move all 1's to ACC"]]
            instrList += [["\"0110011000\"","xor ACC with all 1's"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "SHIFT_LEFT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0101000000\"","shift ACC left"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "SHIF[T_RIGHT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0101100000\"","shift ACC right"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "ROTATE_LEFT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0111000000\"","rotate ACC left"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "ROTATE_RIGHT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0111100000\"","rotate ACC right"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "INVERT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0110011000\"","xor ACC with all 1's"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word.split("_")[0] == "SET":
            instrList += [["\"001010" + self.setBits[4:8] + "\"","set low 4 bits of ACC"]]
            instrList += [["\"001110" + self.setBits[0:4] + "\"","set high 4 bits of ACC"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        else:
            return ("\"1000000000\"; -- branch to beginning when no more instructions\n")
        for instr in instrList:
            newAddr = self.getNewAddress()
            instructions += (instr[0] + 
                             " when addr = \"" + 
                             newAddr +
                             "\" else -- " +
                             instr[1] + "\n")
        if word.split("_")[0] == "DO":
            self.startLoopAddr = self.address
        return instructions
{code}

h5. Add a hold/freeze button to the display.
We simply kept the hold switch we had implemented last time by having a flag on the process containing the state machine that stops it from running if the hold switch is on.

h5. Add one or more switches/buttons that let you speed up or slow down the clock.
Again we kept the button from the first programmable lights project that can cycle through 11 different speeds by picking different bits of the counter to use as the slow clock.
