h1. Programmable Lights II

h3. Write Up

h5. Include a description of your top-level design.

h5. Include the two programs you wrote.

h5. Include the picture of your simulation of your favorite program.

h3. Hardware Testing:

h3. Extensions:

h5. Make longer programs (make the ROM bigger).

h5. Write more programs.

h5. Write a simple assembler (in python, for example) that converts instructions from a simple, human readable language, into the set of machine instructions for your pldrom.

Maybe not so simple, but our vhdlCompiler.py does allow the user to provide english instructions (from a list of valid keywords we define) for a program in an input file, pass that input file to the python on the command line (and optionally specify an output file on the command line as well), which writes vhdl code to the output file for the program described. Our keywords are:
* Do_# - begin a loop that iterates # times
* Loop - end a loop
* Set_######## - sets each of the 8 lights to their #, either 1 or 0
* On - turn all 8 lights on
* Off - turn all 8 lights off
* Shift_Left - shift 8 lights left by one
* Shift_Right - shift 8 lights right by one
* Rotate_Left - rotate rightmost of 8 lights to the leftmost
* Rotate_Right - rotate leftmost of 8 lights to the rightmost
* Invert - flip all on lights to off and visa versa

All instructions in this code refer to the light register (LR, the 8 green lights on the board), so none of the internal implementation (ACC, 10 bit instructions, etc) are visible to the user. Instead, the python code handles validating that they use only legal keywords, do not have neted loops, provide loop counts, do not exceed to number of available addresses, etc. By modifying fields this compiler is extensible to different length addresses, but ours assumes 8 bit addresses and therefore restricts the user to less than 128 loop counts. Our modified table, describing how we modified our design to implement a LOOP register and have 8 bit addresses can be found [here|^newSpecProj5PythExt.htm].

The method that does most of the vhdl composition work is given in the code snippet below:

{code:title=vhdlCompiler.py|borderStyle=solid}
    def getMachineInstructions(self,word):
        instrList = []
        instructions = "-- " + word + "\n"
        if word.split("_")[0] == "DO":
            loopCountStr = "{0:b}".format(self.loopCount)
            if len(loopCountStr) > self.addrLength:
                self.errorMessage += ("Error: new address exceeds give address length" +
                                      " of {}\n".format(self.addrLength))
            while len(loopCountStr) < self.addrLength:
                loopCountStr = "0" + loopCountStr
            instrList += [["\"001010" + loopCountStr[4:8] + "\"","set low 4 bits of ACC"]]
            instrList += [["\"001110" + loopCountStr[0:4] + "\"","set high 4 bits of ACC"]]
            instrList += [["\"0110000100\"","move ACC into LOOP"]]
        elif word == "LOOP":
            instructions += self.subOneFromLOOP()
            branchZWhenAddr = self.getNewAddress()
            branchUWhenAddr = self.getNewAddress()
            branchZToAddr = self.getNewAddress()
            instructions += ("\"11" + branchZToAddr + "\"" + 
                             " when addr = \"" + 
                             branchZWhenAddr +
                             "\" else -- " +
                             "break when LOOP is zero\n")
            instructions += ("\"10" + self.getStartLoopAddr() + "\""
                             " when addr = \"" + 
                             branchUWhenAddr +
                             "\" else -- " +
                             "branch unconditional to top of loop otherwise\n")
        elif word == "ON":
            instrList += [["\"0001110000\"","move all 1's into LR"]]
        elif word == "OFF":
            instrList += [["\"0000110000\"","move all 1's to ACC"]]
            instrList += [["\"0110011000\"","xor ACC with all 1's"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "SHIFT_LEFT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0101000000\"","shift ACC left"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "SHIF[T_RIGHT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0101100000\"","shift ACC right"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "ROTATE_LEFT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0111000000\"","rotate ACC left"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "ROTATE_RIGHT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0111100000\"","rotate ACC right"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word == "INVERT":
            instrList += [["\"0000010000\"","move LR to ACC"]]
            instrList += [["\"0110011000\"","xor ACC with all 1's"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        elif word.split("_")[0] == "SET":
            instrList += [["\"001010" + self.setBits[4:8] + "\"","set low 4 bits of ACC"]]
            instrList += [["\"001110" + self.setBits[0:4] + "\"","set high 4 bits of ACC"]]
            instrList += [["\"0001000000\"","move ACC to LR"]]
        else:
            return ("\"1000000000\"; -- branch to beginning when no more instructions\n")
        for instr in instrList:
            newAddr = self.getNewAddress()
            instructions += (instr[0] + 
                             " when addr = \"" + 
                             newAddr +
                             "\" else -- " +
                             instr[1] + "\n")
        if word.split("_")[0] == "DO":
            self.startLoopAddr = self.address
        return instructions
{code}

h5. Add a hold/freeze button to the display.

h5. Add one or more switches/buttons that let you speed up or slow down the clock.

