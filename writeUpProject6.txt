h1. Moving Memory



h3. Write Up



h5. Include a description of your top-level design.

Our top-level design consisted of a state machine with wizard created RAM and ROM components. The state machine waited a few cycles at start-up to initialize the RAM and ROM, then displayed the contents of the RAM sequentially. It then progressed to loading the contents of ROM into RAM. It then cycles back to displaying the RAM. To make it easier to understand and debug we displayed the current RAM address as a hex character in a 7-segment display.

h5. Include the initial contents of both your RAM and ROM.

ROM:
0 : 00001010;
1 : 00010101;
2 : 00100010;
3 : 00110001;
4 : 01000000;
5 : 10001000;
6 : 11000100;
7 : 01010010;
[8..F] : 11111111;  -- fill A0 to A1 with all 1s

RAM:
0 : 00000001;
1 : 00000010;
2 : 00000101;
3 : 00000110;
4 : 00000111;
5 : 00001000;
6 : 00001001;
7 : 00001010;
[8..F] : 00000000;  -- fill A0 to A1 with all 1s


h3. Hardware Testing (video):




h3. Extensions:



h5. See how few states you can use to execute this task.

We managed to only use 4 total states to execute the task. The first state was the start-up state which simply waited 3 cycles for the memory to initialize. The second state read through each of the memory slots in RAM sequentially to display them. The third state incremented the ROM, loaded the data from the ROM wire to ROM data, and turned off write. The 4th state put the data from ROM to RAM, turned write enable on, and incremented RAM. If every slot of RAM had been accessed then a conditional branch set the state back to 1 for just 1 cycle to turn the write enable off and go back to the first RAM address.



h5. Write a Python program that can generate an MIF file from some other, more easily readable, format.



Our mifCompiler.py does allow the user to provide english instructions (from a list of valid keywords we define) for a program in an input file, pass that input file to the python on the command line (and optionally specify an output file on the command line as well), which writes mif code to the output file for the program described. This uses the same language/lexing of our vhdCompiler (see&nbsp;[Project5|~imtibbet:Ryan Newell and Ian Tibbetts CS232 Project5])



The method that changed to enable mif composition is given in the code snippet below:



{code:title=mifCompiler.py|borderStyle=solid}
    def getMachineInstructions(self,word):
        instructions = "-- " + word + "\n"
        if word.split("_")[0] == "DO":
            self.loopCount = int(word.split("_")[1])
            self.loopInstrs = ""
        elif word == "LOOP":
            oldLoopInstrs = self.loopInstrs
            newLoopInstrs = ""
            for _ in range(self.loopCount):
                for line in oldLoopInstrs.splitlines(True):
                    line = line.lstrip()
                    if line[0:2] == "--":
                        line = self.getMachineInstructions(line.rstrip('\n').split()[1])
                        newLoopInstrs = line
                instructions += newLoopInstrs
            self.loopInstrs = ""
        elif word == "ON":
            self.prevLR = "11111111"
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        elif word == "OFF":
            self.prevLR = "00000000"
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        elif word == "SHIFT_LEFT":
            self.prevLR = self.prevLR[1:7] + "0"
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        elif word == "SHIFT_RIGHT":
            self.prevLR = "0" + self.prevLR[0:6]
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        elif word == "ROTATE_LEFT":
            self.prevLR = self.prevLR[1:7] + self.prevLR[0]
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        elif word == "ROTATE_RIGHT":
            self.prevLR = self.prevLR[0] + self.prevLR[0:6]
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        elif word == "INVERT":
            invertedLR = ""
            for bit in self.prevLR:
                invertedLR += str(int(not(int(bit))))
            self.prevLR = invertedLR
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        elif word.split("_")[0] == "SET":
            self.prevLR = self.setBits
            instructions += self.getNewAddress() + " : " + self.prevLR + ";\n"
            self.loopInstrs += instructions
        else:
            instructions = ""
            twosExp = math.log2(self.address)
            if not int(twosExp) == twosExp:
                instructions += ("[" + str(self.address) + 
                                 ":" + str(int(math.pow(2,math.ceil(twosExp)))-1) + 
                                 "] : 11111111; --Fill remaining with all 1s\n")
            instructions += "END"
        return instructions
{code}



h5. Add a hold/freeze button to the display.

We simply kept the hold switch we had implemented last time by having a flag on the process containing the state machine that stops it from running if the hold switch is on.
